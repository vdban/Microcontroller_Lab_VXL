/*
 * fsm.c
 *
 *  Created on: Nov 27, 2025
 *      Author: ACER
 */
#include "fsm.h"
#include <stdio.h>
#include <string.h>

extern ADC_HandleTypeDef hadc1;
extern UART_HandleTypeDef huart2;

static uint32_t old_value = 0;

int status_parser = 0;
int status = 0;

static uint32_t timeout_timer = 0;
static uint32_t led_timer = 0;

void command_parser_fsm() {
	switch (status_parser) {
		case 0: // Trạng thái chờ ký tự bắt đầu '!'
			if (temp == '!')
				status_parser = 1;
			break;

		case 1: // Đã có '!', chờ 'R' hoặc 'O'
			if (temp == 'R')
				status_parser = 2;
			else if (temp == 'O')
				status_parser = 5;
			else if (temp == '!') // Lỡ tay gõ !! thì vẫn giữ trạng thái này
				status_parser = 1;
			else
				status_parser = 0;
			break;

		// --- NHÁNH XỬ LÝ LỆNH RST ---
		case 2: // Đã có "!R", chờ 'S'
			if (temp == 'S') status_parser = 3;
			else status_parser = 0;
			break;

		case 3: // Đã có "!RS", chờ 'T'
			if (temp == 'T') status_parser = 4;
			else status_parser = 0;
			break;

		case 4: // Đã có "!RST", chờ '#'
			if (temp == '#') {
				command_flag = 1; // Đặt cờ RST
				status_parser = 0;
			} else {
				status_parser = 0;
			}
			break;

		// --- NHÁNH XỬ LÝ LỆNH OK ---
		case 5: // Đã có "!O", chờ 'K'
			if (temp == 'K') status_parser = 6;
			else status_parser = 0;
			break;

		case 6: // Đã có "!OK", chờ '#'
			if (temp == '#') {
				command_flag = 2; // Đặt cờ OK
				status_parser = 0;
			} else {
				status_parser = 0;
			}
			break;

		default:
			status_parser = 0;
			break;
		}
}

void uart_communiation_fsm() {
	char str[30];

		switch (status) {
		case 0: // IDLE
			if (HAL_GetTick() - led_timer >= 500) {
				HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
				led_timer = HAL_GetTick();
			}

			if (command_flag == 1) {
				command_flag = 0;
				status = 1;
			}
			break;

		case 1: // SEND_ADC (Gửi lần đầu)
			// 1. Đọc ADC thực tế
			ADC_value = HAL_ADC_GetValue(&hadc1);

			// 2. LƯU VÀO BIẾN old_value
			old_value = ADC_value;

			// 3. Gửi biến old_value đi
			sprintf(str, "!ADC=%ld#\r\n", old_value);
			HAL_UART_Transmit(&huart2, (uint8_t*)str, 30, 1000);

			// 4. Lưu thời gian và chuyển trạng thái
			timeout_timer = HAL_GetTick();
			status = 2;
			break;

		case 2: // WAIT_OK
			if (command_flag == 2) {
				status = 0;
				command_flag = 0;
			}
			else if (HAL_GetTick() - timeout_timer >= 3000) {
				// --- TIMEOUT ---
				// Chỉ gửi lại biến old_value (Không đọc lại ADC ở đây)
				// Dù bạn có vặn biến trở thì old_value vẫn là số cũ
				sprintf(str, "!ADC=%ld#\r\n", old_value);
				HAL_UART_Transmit(&huart2, (uint8_t*)str, 30, 1000);

				// Reset lại thời gian 3s
				timeout_timer = HAL_GetTick();
			}
			break;

		default:
			status = 0;
			break;
		}
}

/*HAL_UART_Transmit(&huart2, (uint8_t*)str_transmit, strlen(str_transmit), 1000);
		time_start = HAL_GetTick();

		HAL_GetTick() - time_start >= 3000*/
